// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: marineScv.proto

#ifndef PROTOBUF_INCLUDED_marineScv_2eproto
#define PROTOBUF_INCLUDED_marineScv_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_marineScv_2eproto 

namespace protobuf_marineScv_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_marineScv_2eproto
namespace Message {
namespace MarineScv {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class Close;
class CloseDefaultTypeInternal;
extern CloseDefaultTypeInternal _Close_default_instance_;
class Create;
class CreateDefaultTypeInternal;
extern CreateDefaultTypeInternal _Create_default_instance_;
class InitReq;
class InitReqDefaultTypeInternal;
extern InitReqDefaultTypeInternal _InitReq_default_instance_;
class InitRes;
class InitResDefaultTypeInternal;
extern InitResDefaultTypeInternal _InitRes_default_instance_;
class ResetReq;
class ResetReqDefaultTypeInternal;
extern ResetReqDefaultTypeInternal _ResetReq_default_instance_;
class ResetRes;
class ResetResDefaultTypeInternal;
extern ResetResDefaultTypeInternal _ResetRes_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class StepReq;
class StepReqDefaultTypeInternal;
extern StepReqDefaultTypeInternal _StepReq_default_instance_;
class StepRes;
class StepResDefaultTypeInternal;
extern StepResDefaultTypeInternal _StepRes_default_instance_;
class TerrainInfo;
class TerrainInfoDefaultTypeInternal;
extern TerrainInfoDefaultTypeInternal _TerrainInfo_default_instance_;
class TypeInfo;
class TypeInfoDefaultTypeInternal;
extern TypeInfoDefaultTypeInternal _TypeInfo_default_instance_;
class UInfo;
class UInfoDefaultTypeInternal;
extern UInfoDefaultTypeInternal _UInfo_default_instance_;
}  // namespace MarineScv
}  // namespace Message
namespace google {
namespace protobuf {
template<> ::Message::MarineScv::Action* Arena::CreateMaybeMessage<::Message::MarineScv::Action>(Arena*);
template<> ::Message::MarineScv::Close* Arena::CreateMaybeMessage<::Message::MarineScv::Close>(Arena*);
template<> ::Message::MarineScv::Create* Arena::CreateMaybeMessage<::Message::MarineScv::Create>(Arena*);
template<> ::Message::MarineScv::InitReq* Arena::CreateMaybeMessage<::Message::MarineScv::InitReq>(Arena*);
template<> ::Message::MarineScv::InitRes* Arena::CreateMaybeMessage<::Message::MarineScv::InitRes>(Arena*);
template<> ::Message::MarineScv::ResetReq* Arena::CreateMaybeMessage<::Message::MarineScv::ResetReq>(Arena*);
template<> ::Message::MarineScv::ResetRes* Arena::CreateMaybeMessage<::Message::MarineScv::ResetRes>(Arena*);
template<> ::Message::MarineScv::State* Arena::CreateMaybeMessage<::Message::MarineScv::State>(Arena*);
template<> ::Message::MarineScv::StepReq* Arena::CreateMaybeMessage<::Message::MarineScv::StepReq>(Arena*);
template<> ::Message::MarineScv::StepRes* Arena::CreateMaybeMessage<::Message::MarineScv::StepRes>(Arena*);
template<> ::Message::MarineScv::TerrainInfo* Arena::CreateMaybeMessage<::Message::MarineScv::TerrainInfo>(Arena*);
template<> ::Message::MarineScv::TypeInfo* Arena::CreateMaybeMessage<::Message::MarineScv::TypeInfo>(Arena*);
template<> ::Message::MarineScv::UInfo* Arena::CreateMaybeMessage<::Message::MarineScv::UInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Message {
namespace MarineScv {

// ===================================================================

class TypeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.TypeInfo) */ {
 public:
  TypeInfo();
  virtual ~TypeInfo();

  TypeInfo(const TypeInfo& from);

  inline TypeInfo& operator=(const TypeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TypeInfo(TypeInfo&& from) noexcept
    : TypeInfo() {
    *this = ::std::move(from);
  }

  inline TypeInfo& operator=(TypeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TypeInfo* internal_default_instance() {
    return reinterpret_cast<const TypeInfo*>(
               &_TypeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TypeInfo* other);
  friend void swap(TypeInfo& a, TypeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TypeInfo* New() const final {
    return CreateMaybeMessage<TypeInfo>(NULL);
  }

  TypeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TypeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TypeInfo& from);
  void MergeFrom(const TypeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 hp_max = 1;
  void clear_hp_max();
  static const int kHpMaxFieldNumber = 1;
  ::google::protobuf::int32 hp_max() const;
  void set_hp_max(::google::protobuf::int32 value);

  // int32 shield_max = 2;
  void clear_shield_max();
  static const int kShieldMaxFieldNumber = 2;
  ::google::protobuf::int32 shield_max() const;
  void set_shield_max(::google::protobuf::int32 value);

  // int32 energy_max = 3;
  void clear_energy_max();
  static const int kEnergyMaxFieldNumber = 3;
  ::google::protobuf::int32 energy_max() const;
  void set_energy_max(::google::protobuf::int32 value);

  // int32 armor = 4;
  void clear_armor();
  static const int kArmorFieldNumber = 4;
  ::google::protobuf::int32 armor() const;
  void set_armor(::google::protobuf::int32 value);

  // int32 cooldown_max = 5;
  void clear_cooldown_max();
  static const int kCooldownMaxFieldNumber = 5;
  ::google::protobuf::int32 cooldown_max() const;
  void set_cooldown_max(::google::protobuf::int32 value);

  // int32 acceleration = 6;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 6;
  ::google::protobuf::int32 acceleration() const;
  void set_acceleration(::google::protobuf::int32 value);

  // double top_speed = 7;
  void clear_top_speed();
  static const int kTopSpeedFieldNumber = 7;
  double top_speed() const;
  void set_top_speed(double value);

  // int32 damage_amount = 8;
  void clear_damage_amount();
  static const int kDamageAmountFieldNumber = 8;
  ::google::protobuf::int32 damage_amount() const;
  void set_damage_amount(::google::protobuf::int32 value);

  // int32 damage_factor = 9;
  void clear_damage_factor();
  static const int kDamageFactorFieldNumber = 9;
  ::google::protobuf::int32 damage_factor() const;
  void set_damage_factor(::google::protobuf::int32 value);

  // int32 weapon_range = 10;
  void clear_weapon_range();
  static const int kWeaponRangeFieldNumber = 10;
  ::google::protobuf::int32 weapon_range() const;
  void set_weapon_range(::google::protobuf::int32 value);

  // int32 sight_range = 11;
  void clear_sight_range();
  static const int kSightRangeFieldNumber = 11;
  ::google::protobuf::int32 sight_range() const;
  void set_sight_range(::google::protobuf::int32 value);

  // int32 seek_range = 12;
  void clear_seek_range();
  static const int kSeekRangeFieldNumber = 12;
  ::google::protobuf::int32 seek_range() const;
  void set_seek_range(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.TypeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 hp_max_;
  ::google::protobuf::int32 shield_max_;
  ::google::protobuf::int32 energy_max_;
  ::google::protobuf::int32 armor_;
  ::google::protobuf::int32 cooldown_max_;
  ::google::protobuf::int32 acceleration_;
  double top_speed_;
  ::google::protobuf::int32 damage_amount_;
  ::google::protobuf::int32 damage_factor_;
  ::google::protobuf::int32 weapon_range_;
  ::google::protobuf::int32 sight_range_;
  ::google::protobuf::int32 seek_range_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TerrainInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.TerrainInfo) */ {
 public:
  TerrainInfo();
  virtual ~TerrainInfo();

  TerrainInfo(const TerrainInfo& from);

  inline TerrainInfo& operator=(const TerrainInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TerrainInfo(TerrainInfo&& from) noexcept
    : TerrainInfo() {
    *this = ::std::move(from);
  }

  inline TerrainInfo& operator=(TerrainInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TerrainInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TerrainInfo* internal_default_instance() {
    return reinterpret_cast<const TerrainInfo*>(
               &_TerrainInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TerrainInfo* other);
  friend void swap(TerrainInfo& a, TerrainInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TerrainInfo* New() const final {
    return CreateMaybeMessage<TerrainInfo>(NULL);
  }

  TerrainInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TerrainInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TerrainInfo& from);
  void MergeFrom(const TerrainInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerrainInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 nearest_obstacle_dist = 1;
  void clear_nearest_obstacle_dist();
  static const int kNearestObstacleDistFieldNumber = 1;
  ::google::protobuf::int32 nearest_obstacle_dist() const;
  void set_nearest_obstacle_dist(::google::protobuf::int32 value);

  // int32 udi_int_1 = 2;
  void clear_udi_int_1();
  static const int kUdiInt1FieldNumber = 2;
  ::google::protobuf::int32 udi_int_1() const;
  void set_udi_int_1(::google::protobuf::int32 value);

  // int32 udi_int_2 = 3;
  void clear_udi_int_2();
  static const int kUdiInt2FieldNumber = 3;
  ::google::protobuf::int32 udi_int_2() const;
  void set_udi_int_2(::google::protobuf::int32 value);

  // int32 udi_int_3 = 4;
  void clear_udi_int_3();
  static const int kUdiInt3FieldNumber = 4;
  ::google::protobuf::int32 udi_int_3() const;
  void set_udi_int_3(::google::protobuf::int32 value);

  // double udi_double_1 = 6;
  void clear_udi_double_1();
  static const int kUdiDouble1FieldNumber = 6;
  double udi_double_1() const;
  void set_udi_double_1(double value);

  // double udi_double_2 = 7;
  void clear_udi_double_2();
  static const int kUdiDouble2FieldNumber = 7;
  double udi_double_2() const;
  void set_udi_double_2(double value);

  // double udi_double_3 = 8;
  void clear_udi_double_3();
  static const int kUdiDouble3FieldNumber = 8;
  double udi_double_3() const;
  void set_udi_double_3(double value);

  // double udi_double_4 = 9;
  void clear_udi_double_4();
  static const int kUdiDouble4FieldNumber = 9;
  double udi_double_4() const;
  void set_udi_double_4(double value);

  // int32 udi_int_4 = 5;
  void clear_udi_int_4();
  static const int kUdiInt4FieldNumber = 5;
  ::google::protobuf::int32 udi_int_4() const;
  void set_udi_int_4(::google::protobuf::int32 value);

  // bool udi_bool_1 = 10;
  void clear_udi_bool_1();
  static const int kUdiBool1FieldNumber = 10;
  bool udi_bool_1() const;
  void set_udi_bool_1(bool value);

  // bool udi_bool_2 = 11;
  void clear_udi_bool_2();
  static const int kUdiBool2FieldNumber = 11;
  bool udi_bool_2() const;
  void set_udi_bool_2(bool value);

  // bool udi_bool_3 = 12;
  void clear_udi_bool_3();
  static const int kUdiBool3FieldNumber = 12;
  bool udi_bool_3() const;
  void set_udi_bool_3(bool value);

  // bool udi_bool_4 = 13;
  void clear_udi_bool_4();
  static const int kUdiBool4FieldNumber = 13;
  bool udi_bool_4() const;
  void set_udi_bool_4(bool value);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.TerrainInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 nearest_obstacle_dist_;
  ::google::protobuf::int32 udi_int_1_;
  ::google::protobuf::int32 udi_int_2_;
  ::google::protobuf::int32 udi_int_3_;
  double udi_double_1_;
  double udi_double_2_;
  double udi_double_3_;
  double udi_double_4_;
  ::google::protobuf::int32 udi_int_4_;
  bool udi_bool_1_;
  bool udi_bool_2_;
  bool udi_bool_3_;
  bool udi_bool_4_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.UInfo) */ {
 public:
  UInfo();
  virtual ~UInfo();

  UInfo(const UInfo& from);

  inline UInfo& operator=(const UInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInfo(UInfo&& from) noexcept
    : UInfo() {
    *this = ::std::move(from);
  }

  inline UInfo& operator=(UInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UInfo* internal_default_instance() {
    return reinterpret_cast<const UInfo*>(
               &_UInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UInfo* other);
  friend void swap(UInfo& a, UInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInfo* New() const final {
    return CreateMaybeMessage<UInfo>(NULL);
  }

  UInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UInfo& from);
  void MergeFrom(const UInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Message.MarineScv.TerrainInfo pos_info = 14;
  int pos_info_size() const;
  void clear_pos_info();
  static const int kPosInfoFieldNumber = 14;
  ::Message::MarineScv::TerrainInfo* mutable_pos_info(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::TerrainInfo >*
      mutable_pos_info();
  const ::Message::MarineScv::TerrainInfo& pos_info(int index) const;
  ::Message::MarineScv::TerrainInfo* add_pos_info();
  const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::TerrainInfo >&
      pos_info() const;

  // int32 hp = 1;
  void clear_hp();
  static const int kHpFieldNumber = 1;
  ::google::protobuf::int32 hp() const;
  void set_hp(::google::protobuf::int32 value);

  // int32 shield = 2;
  void clear_shield();
  static const int kShieldFieldNumber = 2;
  ::google::protobuf::int32 shield() const;
  void set_shield(::google::protobuf::int32 value);

  // int32 energy = 3;
  void clear_energy();
  static const int kEnergyFieldNumber = 3;
  ::google::protobuf::int32 energy() const;
  void set_energy(::google::protobuf::int32 value);

  // int32 cooldown = 4;
  void clear_cooldown();
  static const int kCooldownFieldNumber = 4;
  ::google::protobuf::int32 cooldown() const;
  void set_cooldown(::google::protobuf::int32 value);

  // int32 pos_x = 5;
  void clear_pos_x();
  static const int kPosXFieldNumber = 5;
  ::google::protobuf::int32 pos_x() const;
  void set_pos_x(::google::protobuf::int32 value);

  // int32 pos_y = 6;
  void clear_pos_y();
  static const int kPosYFieldNumber = 6;
  ::google::protobuf::int32 pos_y() const;
  void set_pos_y(::google::protobuf::int32 value);

  // double velocity_x = 7;
  void clear_velocity_x();
  static const int kVelocityXFieldNumber = 7;
  double velocity_x() const;
  void set_velocity_x(double value);

  // double velocity_y = 8;
  void clear_velocity_y();
  static const int kVelocityYFieldNumber = 8;
  double velocity_y() const;
  void set_velocity_y(double value);

  // double angle = 9;
  void clear_angle();
  static const int kAngleFieldNumber = 9;
  double angle() const;
  void set_angle(double value);

  // bool accelerating = 10;
  void clear_accelerating();
  static const int kAcceleratingFieldNumber = 10;
  bool accelerating() const;
  void set_accelerating(bool value);

  // bool braking = 11;
  void clear_braking();
  static const int kBrakingFieldNumber = 11;
  bool braking() const;
  void set_braking(bool value);

  // bool attacking = 12;
  void clear_attacking();
  static const int kAttackingFieldNumber = 12;
  bool attacking() const;
  void set_attacking(bool value);

  // bool is_attack_frame = 13;
  void clear_is_attack_frame();
  static const int kIsAttackFrameFieldNumber = 13;
  bool is_attack_frame() const;
  void set_is_attack_frame(bool value);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.UInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::TerrainInfo > pos_info_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 shield_;
  ::google::protobuf::int32 energy_;
  ::google::protobuf::int32 cooldown_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  double velocity_x_;
  double velocity_y_;
  double angle_;
  bool accelerating_;
  bool braking_;
  bool attacking_;
  bool is_attack_frame_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Action* other);
  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(NULL);
  }

  Action* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 pos_x = 1;
  void clear_pos_x();
  static const int kPosXFieldNumber = 1;
  ::google::protobuf::int32 pos_x() const;
  void set_pos_x(::google::protobuf::int32 value);

  // int32 pos_y = 2;
  void clear_pos_y();
  static const int kPosYFieldNumber = 2;
  ::google::protobuf::int32 pos_y() const;
  void set_pos_y(::google::protobuf::int32 value);

  // int32 radius = 3;
  void clear_radius();
  static const int kRadiusFieldNumber = 3;
  ::google::protobuf::int32 radius() const;
  void set_radius(::google::protobuf::int32 value);

  // float angle = 4;
  void clear_angle();
  static const int kAngleFieldNumber = 4;
  float angle() const;
  void set_angle(float value);

  // int32 action_num = 5;
  void clear_action_num();
  static const int kActionNumFieldNumber = 5;
  ::google::protobuf::int32 action_num() const;
  void set_action_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.Action)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  ::google::protobuf::int32 radius_;
  float angle_;
  ::google::protobuf::int32 action_num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.InitReq) */ {
 public:
  InitReq();
  virtual ~InitReq();

  InitReq(const InitReq& from);

  inline InitReq& operator=(const InitReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitReq(InitReq&& from) noexcept
    : InitReq() {
    *this = ::std::move(from);
  }

  inline InitReq& operator=(InitReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitReq* internal_default_instance() {
    return reinterpret_cast<const InitReq*>(
               &_InitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InitReq* other);
  friend void swap(InitReq& a, InitReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitReq* New() const final {
    return CreateMaybeMessage<InitReq>(NULL);
  }

  InitReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitReq& from);
  void MergeFrom(const InitReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // int32 action_type = 2;
  void clear_action_type();
  static const int kActionTypeFieldNumber = 2;
  ::google::protobuf::int32 action_type() const;
  void set_action_type(::google::protobuf::int32 value);

  // int32 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // int32 frames_per_step = 4;
  void clear_frames_per_step();
  static const int kFramesPerStepFieldNumber = 4;
  ::google::protobuf::int32 frames_per_step() const;
  void set_frames_per_step(::google::protobuf::int32 value);

  // int32 move_angle = 5;
  void clear_move_angle();
  static const int kMoveAngleFieldNumber = 5;
  ::google::protobuf::int32 move_angle() const;
  void set_move_angle(::google::protobuf::int32 value);

  // int32 move_dist = 6;
  void clear_move_dist();
  static const int kMoveDistFieldNumber = 6;
  ::google::protobuf::int32 move_dist() const;
  void set_move_dist(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.InitReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::int32 action_type_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 frames_per_step_;
  ::google::protobuf::int32 move_angle_;
  ::google::protobuf::int32 move_dist_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.InitRes) */ {
 public:
  InitRes();
  virtual ~InitRes();

  InitRes(const InitRes& from);

  inline InitRes& operator=(const InitRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitRes(InitRes&& from) noexcept
    : InitRes() {
    *this = ::std::move(from);
  }

  inline InitRes& operator=(InitRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitRes* internal_default_instance() {
    return reinterpret_cast<const InitRes*>(
               &_InitRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(InitRes* other);
  friend void swap(InitRes& a, InitRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitRes* New() const final {
    return CreateMaybeMessage<InitRes>(NULL);
  }

  InitRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitRes& from);
  void MergeFrom(const InitRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool iswalkable = 5;
  int iswalkable_size() const;
  void clear_iswalkable();
  static const int kIswalkableFieldNumber = 5;
  bool iswalkable(int index) const;
  void set_iswalkable(int index, bool value);
  void add_iswalkable(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      iswalkable() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_iswalkable();

  // .Message.MarineScv.TypeInfo my_marine_type = 2;
  bool has_my_marine_type() const;
  void clear_my_marine_type();
  static const int kMyMarineTypeFieldNumber = 2;
  private:
  const ::Message::MarineScv::TypeInfo& _internal_my_marine_type() const;
  public:
  const ::Message::MarineScv::TypeInfo& my_marine_type() const;
  ::Message::MarineScv::TypeInfo* release_my_marine_type();
  ::Message::MarineScv::TypeInfo* mutable_my_marine_type();
  void set_allocated_my_marine_type(::Message::MarineScv::TypeInfo* my_marine_type);

  // .Message.MarineScv.TypeInfo my_scv_type = 3;
  bool has_my_scv_type() const;
  void clear_my_scv_type();
  static const int kMyScvTypeFieldNumber = 3;
  private:
  const ::Message::MarineScv::TypeInfo& _internal_my_scv_type() const;
  public:
  const ::Message::MarineScv::TypeInfo& my_scv_type() const;
  ::Message::MarineScv::TypeInfo* release_my_scv_type();
  ::Message::MarineScv::TypeInfo* mutable_my_scv_type();
  void set_allocated_my_scv_type(::Message::MarineScv::TypeInfo* my_scv_type);

  // .Message.MarineScv.TypeInfo en_unit_type = 4;
  bool has_en_unit_type() const;
  void clear_en_unit_type();
  static const int kEnUnitTypeFieldNumber = 4;
  private:
  const ::Message::MarineScv::TypeInfo& _internal_en_unit_type() const;
  public:
  const ::Message::MarineScv::TypeInfo& en_unit_type() const;
  ::Message::MarineScv::TypeInfo* release_en_unit_type();
  ::Message::MarineScv::TypeInfo* mutable_en_unit_type();
  void set_allocated_en_unit_type(::Message::MarineScv::TypeInfo* en_unit_type);

  // int32 num_action_space = 1;
  void clear_num_action_space();
  static const int kNumActionSpaceFieldNumber = 1;
  ::google::protobuf::int32 num_action_space() const;
  void set_num_action_space(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.InitRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< bool > iswalkable_;
  mutable int _iswalkable_cached_byte_size_;
  ::Message::MarineScv::TypeInfo* my_marine_type_;
  ::Message::MarineScv::TypeInfo* my_scv_type_;
  ::Message::MarineScv::TypeInfo* en_unit_type_;
  ::google::protobuf::int32 num_action_space_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StepReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.StepReq) */ {
 public:
  StepReq();
  virtual ~StepReq();

  StepReq(const StepReq& from);

  inline StepReq& operator=(const StepReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StepReq(StepReq&& from) noexcept
    : StepReq() {
    *this = ::std::move(from);
  }

  inline StepReq& operator=(StepReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StepReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StepReq* internal_default_instance() {
    return reinterpret_cast<const StepReq*>(
               &_StepReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(StepReq* other);
  friend void swap(StepReq& a, StepReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StepReq* New() const final {
    return CreateMaybeMessage<StepReq>(NULL);
  }

  StepReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StepReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StepReq& from);
  void MergeFrom(const StepReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Message.MarineScv.Action action = 1;
  int action_size() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::Message::MarineScv::Action* mutable_action(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::Action >*
      mutable_action();
  const ::Message::MarineScv::Action& action(int index) const;
  ::Message::MarineScv::Action* add_action();
  const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::Action >&
      action() const;

  // @@protoc_insertion_point(class_scope:Message.MarineScv.StepReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::Action > action_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.State) */ {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(State&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(State* other);
  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State* New() const final {
    return CreateMaybeMessage<State>(NULL);
  }

  State* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Message.MarineScv.UInfo my_marine = 1;
  int my_marine_size() const;
  void clear_my_marine();
  static const int kMyMarineFieldNumber = 1;
  ::Message::MarineScv::UInfo* mutable_my_marine(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >*
      mutable_my_marine();
  const ::Message::MarineScv::UInfo& my_marine(int index) const;
  ::Message::MarineScv::UInfo* add_my_marine();
  const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >&
      my_marine() const;

  // repeated .Message.MarineScv.UInfo my_scv = 2;
  int my_scv_size() const;
  void clear_my_scv();
  static const int kMyScvFieldNumber = 2;
  ::Message::MarineScv::UInfo* mutable_my_scv(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >*
      mutable_my_scv();
  const ::Message::MarineScv::UInfo& my_scv(int index) const;
  ::Message::MarineScv::UInfo* add_my_scv();
  const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >&
      my_scv() const;

  // repeated .Message.MarineScv.UInfo en_unit = 3;
  int en_unit_size() const;
  void clear_en_unit();
  static const int kEnUnitFieldNumber = 3;
  ::Message::MarineScv::UInfo* mutable_en_unit(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >*
      mutable_en_unit();
  const ::Message::MarineScv::UInfo& en_unit(int index) const;
  ::Message::MarineScv::UInfo* add_en_unit();
  const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >&
      en_unit() const;

  // @@protoc_insertion_point(class_scope:Message.MarineScv.State)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo > my_marine_;
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo > my_scv_;
  ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo > en_unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StepRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.StepRes) */ {
 public:
  StepRes();
  virtual ~StepRes();

  StepRes(const StepRes& from);

  inline StepRes& operator=(const StepRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StepRes(StepRes&& from) noexcept
    : StepRes() {
    *this = ::std::move(from);
  }

  inline StepRes& operator=(StepRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StepRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StepRes* internal_default_instance() {
    return reinterpret_cast<const StepRes*>(
               &_StepRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(StepRes* other);
  friend void swap(StepRes& a, StepRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StepRes* New() const final {
    return CreateMaybeMessage<StepRes>(NULL);
  }

  StepRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StepRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StepRes& from);
  void MergeFrom(const StepRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Message.MarineScv.State next_state = 3;
  bool has_next_state() const;
  void clear_next_state();
  static const int kNextStateFieldNumber = 3;
  private:
  const ::Message::MarineScv::State& _internal_next_state() const;
  public:
  const ::Message::MarineScv::State& next_state() const;
  ::Message::MarineScv::State* release_next_state();
  ::Message::MarineScv::State* mutable_next_state();
  void set_allocated_next_state(::Message::MarineScv::State* next_state);

  // int32 done = 1;
  void clear_done();
  static const int kDoneFieldNumber = 1;
  ::google::protobuf::int32 done() const;
  void set_done(::google::protobuf::int32 value);

  // float reward = 2;
  void clear_reward();
  static const int kRewardFieldNumber = 2;
  float reward() const;
  void set_reward(float value);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.StepRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Message::MarineScv::State* next_state_;
  ::google::protobuf::int32 done_;
  float reward_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.ResetReq) */ {
 public:
  ResetReq();
  virtual ~ResetReq();

  ResetReq(const ResetReq& from);

  inline ResetReq& operator=(const ResetReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetReq(ResetReq&& from) noexcept
    : ResetReq() {
    *this = ::std::move(from);
  }

  inline ResetReq& operator=(ResetReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetReq* internal_default_instance() {
    return reinterpret_cast<const ResetReq*>(
               &_ResetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ResetReq* other);
  friend void swap(ResetReq& a, ResetReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetReq* New() const final {
    return CreateMaybeMessage<ResetReq>(NULL);
  }

  ResetReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResetReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResetReq& from);
  void MergeFrom(const ResetReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.ResetReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.ResetRes) */ {
 public:
  ResetRes();
  virtual ~ResetRes();

  ResetRes(const ResetRes& from);

  inline ResetRes& operator=(const ResetRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetRes(ResetRes&& from) noexcept
    : ResetRes() {
    *this = ::std::move(from);
  }

  inline ResetRes& operator=(ResetRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetRes* internal_default_instance() {
    return reinterpret_cast<const ResetRes*>(
               &_ResetRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ResetRes* other);
  friend void swap(ResetRes& a, ResetRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetRes* New() const final {
    return CreateMaybeMessage<ResetRes>(NULL);
  }

  ResetRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResetRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResetRes& from);
  void MergeFrom(const ResetRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Message.MarineScv.State next_state = 1;
  bool has_next_state() const;
  void clear_next_state();
  static const int kNextStateFieldNumber = 1;
  private:
  const ::Message::MarineScv::State& _internal_next_state() const;
  public:
  const ::Message::MarineScv::State& next_state() const;
  ::Message::MarineScv::State* release_next_state();
  ::Message::MarineScv::State* mutable_next_state();
  void set_allocated_next_state(::Message::MarineScv::State* next_state);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.ResetRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Message::MarineScv::State* next_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Create : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.Create) */ {
 public:
  Create();
  virtual ~Create();

  Create(const Create& from);

  inline Create& operator=(const Create& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Create(Create&& from) noexcept
    : Create() {
    *this = ::std::move(from);
  }

  inline Create& operator=(Create&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Create& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Create* internal_default_instance() {
    return reinterpret_cast<const Create*>(
               &_Create_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Create* other);
  friend void swap(Create& a, Create& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Create* New() const final {
    return CreateMaybeMessage<Create>(NULL);
  }

  Create* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Create>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Create& from);
  void MergeFrom(const Create& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Create* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.Create)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Close : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message.MarineScv.Close) */ {
 public:
  Close();
  virtual ~Close();

  Close(const Close& from);

  inline Close& operator=(const Close& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Close(Close&& from) noexcept
    : Close() {
    *this = ::std::move(from);
  }

  inline Close& operator=(Close&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Close& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Close* internal_default_instance() {
    return reinterpret_cast<const Close*>(
               &_Close_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Close* other);
  friend void swap(Close& a, Close& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Close* New() const final {
    return CreateMaybeMessage<Close>(NULL);
  }

  Close* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Close>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Close& from);
  void MergeFrom(const Close& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Close* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Message.MarineScv.Close)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_marineScv_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TypeInfo

// int32 hp_max = 1;
inline void TypeInfo::clear_hp_max() {
  hp_max_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::hp_max() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.hp_max)
  return hp_max_;
}
inline void TypeInfo::set_hp_max(::google::protobuf::int32 value) {
  
  hp_max_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.hp_max)
}

// int32 shield_max = 2;
inline void TypeInfo::clear_shield_max() {
  shield_max_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::shield_max() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.shield_max)
  return shield_max_;
}
inline void TypeInfo::set_shield_max(::google::protobuf::int32 value) {
  
  shield_max_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.shield_max)
}

// int32 energy_max = 3;
inline void TypeInfo::clear_energy_max() {
  energy_max_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::energy_max() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.energy_max)
  return energy_max_;
}
inline void TypeInfo::set_energy_max(::google::protobuf::int32 value) {
  
  energy_max_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.energy_max)
}

// int32 armor = 4;
inline void TypeInfo::clear_armor() {
  armor_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::armor() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.armor)
  return armor_;
}
inline void TypeInfo::set_armor(::google::protobuf::int32 value) {
  
  armor_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.armor)
}

// int32 cooldown_max = 5;
inline void TypeInfo::clear_cooldown_max() {
  cooldown_max_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::cooldown_max() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.cooldown_max)
  return cooldown_max_;
}
inline void TypeInfo::set_cooldown_max(::google::protobuf::int32 value) {
  
  cooldown_max_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.cooldown_max)
}

// int32 acceleration = 6;
inline void TypeInfo::clear_acceleration() {
  acceleration_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::acceleration() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.acceleration)
  return acceleration_;
}
inline void TypeInfo::set_acceleration(::google::protobuf::int32 value) {
  
  acceleration_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.acceleration)
}

// double top_speed = 7;
inline void TypeInfo::clear_top_speed() {
  top_speed_ = 0;
}
inline double TypeInfo::top_speed() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.top_speed)
  return top_speed_;
}
inline void TypeInfo::set_top_speed(double value) {
  
  top_speed_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.top_speed)
}

// int32 damage_amount = 8;
inline void TypeInfo::clear_damage_amount() {
  damage_amount_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::damage_amount() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.damage_amount)
  return damage_amount_;
}
inline void TypeInfo::set_damage_amount(::google::protobuf::int32 value) {
  
  damage_amount_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.damage_amount)
}

// int32 damage_factor = 9;
inline void TypeInfo::clear_damage_factor() {
  damage_factor_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::damage_factor() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.damage_factor)
  return damage_factor_;
}
inline void TypeInfo::set_damage_factor(::google::protobuf::int32 value) {
  
  damage_factor_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.damage_factor)
}

// int32 weapon_range = 10;
inline void TypeInfo::clear_weapon_range() {
  weapon_range_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::weapon_range() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.weapon_range)
  return weapon_range_;
}
inline void TypeInfo::set_weapon_range(::google::protobuf::int32 value) {
  
  weapon_range_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.weapon_range)
}

// int32 sight_range = 11;
inline void TypeInfo::clear_sight_range() {
  sight_range_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::sight_range() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.sight_range)
  return sight_range_;
}
inline void TypeInfo::set_sight_range(::google::protobuf::int32 value) {
  
  sight_range_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.sight_range)
}

// int32 seek_range = 12;
inline void TypeInfo::clear_seek_range() {
  seek_range_ = 0;
}
inline ::google::protobuf::int32 TypeInfo::seek_range() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TypeInfo.seek_range)
  return seek_range_;
}
inline void TypeInfo::set_seek_range(::google::protobuf::int32 value) {
  
  seek_range_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TypeInfo.seek_range)
}

// -------------------------------------------------------------------

// TerrainInfo

// int32 nearest_obstacle_dist = 1;
inline void TerrainInfo::clear_nearest_obstacle_dist() {
  nearest_obstacle_dist_ = 0;
}
inline ::google::protobuf::int32 TerrainInfo::nearest_obstacle_dist() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.nearest_obstacle_dist)
  return nearest_obstacle_dist_;
}
inline void TerrainInfo::set_nearest_obstacle_dist(::google::protobuf::int32 value) {
  
  nearest_obstacle_dist_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.nearest_obstacle_dist)
}

// int32 udi_int_1 = 2;
inline void TerrainInfo::clear_udi_int_1() {
  udi_int_1_ = 0;
}
inline ::google::protobuf::int32 TerrainInfo::udi_int_1() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_int_1)
  return udi_int_1_;
}
inline void TerrainInfo::set_udi_int_1(::google::protobuf::int32 value) {
  
  udi_int_1_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_int_1)
}

// int32 udi_int_2 = 3;
inline void TerrainInfo::clear_udi_int_2() {
  udi_int_2_ = 0;
}
inline ::google::protobuf::int32 TerrainInfo::udi_int_2() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_int_2)
  return udi_int_2_;
}
inline void TerrainInfo::set_udi_int_2(::google::protobuf::int32 value) {
  
  udi_int_2_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_int_2)
}

// int32 udi_int_3 = 4;
inline void TerrainInfo::clear_udi_int_3() {
  udi_int_3_ = 0;
}
inline ::google::protobuf::int32 TerrainInfo::udi_int_3() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_int_3)
  return udi_int_3_;
}
inline void TerrainInfo::set_udi_int_3(::google::protobuf::int32 value) {
  
  udi_int_3_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_int_3)
}

// int32 udi_int_4 = 5;
inline void TerrainInfo::clear_udi_int_4() {
  udi_int_4_ = 0;
}
inline ::google::protobuf::int32 TerrainInfo::udi_int_4() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_int_4)
  return udi_int_4_;
}
inline void TerrainInfo::set_udi_int_4(::google::protobuf::int32 value) {
  
  udi_int_4_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_int_4)
}

// double udi_double_1 = 6;
inline void TerrainInfo::clear_udi_double_1() {
  udi_double_1_ = 0;
}
inline double TerrainInfo::udi_double_1() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_double_1)
  return udi_double_1_;
}
inline void TerrainInfo::set_udi_double_1(double value) {
  
  udi_double_1_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_double_1)
}

// double udi_double_2 = 7;
inline void TerrainInfo::clear_udi_double_2() {
  udi_double_2_ = 0;
}
inline double TerrainInfo::udi_double_2() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_double_2)
  return udi_double_2_;
}
inline void TerrainInfo::set_udi_double_2(double value) {
  
  udi_double_2_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_double_2)
}

// double udi_double_3 = 8;
inline void TerrainInfo::clear_udi_double_3() {
  udi_double_3_ = 0;
}
inline double TerrainInfo::udi_double_3() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_double_3)
  return udi_double_3_;
}
inline void TerrainInfo::set_udi_double_3(double value) {
  
  udi_double_3_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_double_3)
}

// double udi_double_4 = 9;
inline void TerrainInfo::clear_udi_double_4() {
  udi_double_4_ = 0;
}
inline double TerrainInfo::udi_double_4() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_double_4)
  return udi_double_4_;
}
inline void TerrainInfo::set_udi_double_4(double value) {
  
  udi_double_4_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_double_4)
}

// bool udi_bool_1 = 10;
inline void TerrainInfo::clear_udi_bool_1() {
  udi_bool_1_ = false;
}
inline bool TerrainInfo::udi_bool_1() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_bool_1)
  return udi_bool_1_;
}
inline void TerrainInfo::set_udi_bool_1(bool value) {
  
  udi_bool_1_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_bool_1)
}

// bool udi_bool_2 = 11;
inline void TerrainInfo::clear_udi_bool_2() {
  udi_bool_2_ = false;
}
inline bool TerrainInfo::udi_bool_2() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_bool_2)
  return udi_bool_2_;
}
inline void TerrainInfo::set_udi_bool_2(bool value) {
  
  udi_bool_2_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_bool_2)
}

// bool udi_bool_3 = 12;
inline void TerrainInfo::clear_udi_bool_3() {
  udi_bool_3_ = false;
}
inline bool TerrainInfo::udi_bool_3() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_bool_3)
  return udi_bool_3_;
}
inline void TerrainInfo::set_udi_bool_3(bool value) {
  
  udi_bool_3_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_bool_3)
}

// bool udi_bool_4 = 13;
inline void TerrainInfo::clear_udi_bool_4() {
  udi_bool_4_ = false;
}
inline bool TerrainInfo::udi_bool_4() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.TerrainInfo.udi_bool_4)
  return udi_bool_4_;
}
inline void TerrainInfo::set_udi_bool_4(bool value) {
  
  udi_bool_4_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.TerrainInfo.udi_bool_4)
}

// -------------------------------------------------------------------

// UInfo

// int32 hp = 1;
inline void UInfo::clear_hp() {
  hp_ = 0;
}
inline ::google::protobuf::int32 UInfo::hp() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.hp)
  return hp_;
}
inline void UInfo::set_hp(::google::protobuf::int32 value) {
  
  hp_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.hp)
}

// int32 shield = 2;
inline void UInfo::clear_shield() {
  shield_ = 0;
}
inline ::google::protobuf::int32 UInfo::shield() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.shield)
  return shield_;
}
inline void UInfo::set_shield(::google::protobuf::int32 value) {
  
  shield_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.shield)
}

// int32 energy = 3;
inline void UInfo::clear_energy() {
  energy_ = 0;
}
inline ::google::protobuf::int32 UInfo::energy() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.energy)
  return energy_;
}
inline void UInfo::set_energy(::google::protobuf::int32 value) {
  
  energy_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.energy)
}

// int32 cooldown = 4;
inline void UInfo::clear_cooldown() {
  cooldown_ = 0;
}
inline ::google::protobuf::int32 UInfo::cooldown() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.cooldown)
  return cooldown_;
}
inline void UInfo::set_cooldown(::google::protobuf::int32 value) {
  
  cooldown_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.cooldown)
}

// int32 pos_x = 5;
inline void UInfo::clear_pos_x() {
  pos_x_ = 0;
}
inline ::google::protobuf::int32 UInfo::pos_x() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.pos_x)
  return pos_x_;
}
inline void UInfo::set_pos_x(::google::protobuf::int32 value) {
  
  pos_x_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.pos_x)
}

// int32 pos_y = 6;
inline void UInfo::clear_pos_y() {
  pos_y_ = 0;
}
inline ::google::protobuf::int32 UInfo::pos_y() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.pos_y)
  return pos_y_;
}
inline void UInfo::set_pos_y(::google::protobuf::int32 value) {
  
  pos_y_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.pos_y)
}

// double velocity_x = 7;
inline void UInfo::clear_velocity_x() {
  velocity_x_ = 0;
}
inline double UInfo::velocity_x() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.velocity_x)
  return velocity_x_;
}
inline void UInfo::set_velocity_x(double value) {
  
  velocity_x_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.velocity_x)
}

// double velocity_y = 8;
inline void UInfo::clear_velocity_y() {
  velocity_y_ = 0;
}
inline double UInfo::velocity_y() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.velocity_y)
  return velocity_y_;
}
inline void UInfo::set_velocity_y(double value) {
  
  velocity_y_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.velocity_y)
}

// double angle = 9;
inline void UInfo::clear_angle() {
  angle_ = 0;
}
inline double UInfo::angle() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.angle)
  return angle_;
}
inline void UInfo::set_angle(double value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.angle)
}

// bool accelerating = 10;
inline void UInfo::clear_accelerating() {
  accelerating_ = false;
}
inline bool UInfo::accelerating() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.accelerating)
  return accelerating_;
}
inline void UInfo::set_accelerating(bool value) {
  
  accelerating_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.accelerating)
}

// bool braking = 11;
inline void UInfo::clear_braking() {
  braking_ = false;
}
inline bool UInfo::braking() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.braking)
  return braking_;
}
inline void UInfo::set_braking(bool value) {
  
  braking_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.braking)
}

// bool attacking = 12;
inline void UInfo::clear_attacking() {
  attacking_ = false;
}
inline bool UInfo::attacking() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.attacking)
  return attacking_;
}
inline void UInfo::set_attacking(bool value) {
  
  attacking_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.attacking)
}

// bool is_attack_frame = 13;
inline void UInfo::clear_is_attack_frame() {
  is_attack_frame_ = false;
}
inline bool UInfo::is_attack_frame() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.is_attack_frame)
  return is_attack_frame_;
}
inline void UInfo::set_is_attack_frame(bool value) {
  
  is_attack_frame_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.UInfo.is_attack_frame)
}

// repeated .Message.MarineScv.TerrainInfo pos_info = 14;
inline int UInfo::pos_info_size() const {
  return pos_info_.size();
}
inline void UInfo::clear_pos_info() {
  pos_info_.Clear();
}
inline ::Message::MarineScv::TerrainInfo* UInfo::mutable_pos_info(int index) {
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.UInfo.pos_info)
  return pos_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::TerrainInfo >*
UInfo::mutable_pos_info() {
  // @@protoc_insertion_point(field_mutable_list:Message.MarineScv.UInfo.pos_info)
  return &pos_info_;
}
inline const ::Message::MarineScv::TerrainInfo& UInfo::pos_info(int index) const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.UInfo.pos_info)
  return pos_info_.Get(index);
}
inline ::Message::MarineScv::TerrainInfo* UInfo::add_pos_info() {
  // @@protoc_insertion_point(field_add:Message.MarineScv.UInfo.pos_info)
  return pos_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::TerrainInfo >&
UInfo::pos_info() const {
  // @@protoc_insertion_point(field_list:Message.MarineScv.UInfo.pos_info)
  return pos_info_;
}

// -------------------------------------------------------------------

// Action

// int32 pos_x = 1;
inline void Action::clear_pos_x() {
  pos_x_ = 0;
}
inline ::google::protobuf::int32 Action::pos_x() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.Action.pos_x)
  return pos_x_;
}
inline void Action::set_pos_x(::google::protobuf::int32 value) {
  
  pos_x_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.Action.pos_x)
}

// int32 pos_y = 2;
inline void Action::clear_pos_y() {
  pos_y_ = 0;
}
inline ::google::protobuf::int32 Action::pos_y() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.Action.pos_y)
  return pos_y_;
}
inline void Action::set_pos_y(::google::protobuf::int32 value) {
  
  pos_y_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.Action.pos_y)
}

// int32 radius = 3;
inline void Action::clear_radius() {
  radius_ = 0;
}
inline ::google::protobuf::int32 Action::radius() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.Action.radius)
  return radius_;
}
inline void Action::set_radius(::google::protobuf::int32 value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.Action.radius)
}

// float angle = 4;
inline void Action::clear_angle() {
  angle_ = 0;
}
inline float Action::angle() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.Action.angle)
  return angle_;
}
inline void Action::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.Action.angle)
}

// int32 action_num = 5;
inline void Action::clear_action_num() {
  action_num_ = 0;
}
inline ::google::protobuf::int32 Action::action_num() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.Action.action_num)
  return action_num_;
}
inline void Action::set_action_num(::google::protobuf::int32 value) {
  
  action_num_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.Action.action_num)
}

// -------------------------------------------------------------------

// InitReq

// string content = 1;
inline void InitReq::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InitReq::content() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitReq.content)
  return content_.GetNoArena();
}
inline void InitReq::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Message.MarineScv.InitReq.content)
}
#if LANG_CXX11
inline void InitReq::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Message.MarineScv.InitReq.content)
}
#endif
inline void InitReq::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Message.MarineScv.InitReq.content)
}
inline void InitReq::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Message.MarineScv.InitReq.content)
}
inline ::std::string* InitReq::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.InitReq.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitReq::release_content() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.InitReq.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitReq::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.InitReq.content)
}

// int32 action_type = 2;
inline void InitReq::clear_action_type() {
  action_type_ = 0;
}
inline ::google::protobuf::int32 InitReq::action_type() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitReq.action_type)
  return action_type_;
}
inline void InitReq::set_action_type(::google::protobuf::int32 value) {
  
  action_type_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.InitReq.action_type)
}

// int32 version = 3;
inline void InitReq::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 InitReq::version() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitReq.version)
  return version_;
}
inline void InitReq::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.InitReq.version)
}

// int32 frames_per_step = 4;
inline void InitReq::clear_frames_per_step() {
  frames_per_step_ = 0;
}
inline ::google::protobuf::int32 InitReq::frames_per_step() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitReq.frames_per_step)
  return frames_per_step_;
}
inline void InitReq::set_frames_per_step(::google::protobuf::int32 value) {
  
  frames_per_step_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.InitReq.frames_per_step)
}

// int32 move_angle = 5;
inline void InitReq::clear_move_angle() {
  move_angle_ = 0;
}
inline ::google::protobuf::int32 InitReq::move_angle() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitReq.move_angle)
  return move_angle_;
}
inline void InitReq::set_move_angle(::google::protobuf::int32 value) {
  
  move_angle_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.InitReq.move_angle)
}

// int32 move_dist = 6;
inline void InitReq::clear_move_dist() {
  move_dist_ = 0;
}
inline ::google::protobuf::int32 InitReq::move_dist() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitReq.move_dist)
  return move_dist_;
}
inline void InitReq::set_move_dist(::google::protobuf::int32 value) {
  
  move_dist_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.InitReq.move_dist)
}

// -------------------------------------------------------------------

// InitRes

// int32 num_action_space = 1;
inline void InitRes::clear_num_action_space() {
  num_action_space_ = 0;
}
inline ::google::protobuf::int32 InitRes::num_action_space() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitRes.num_action_space)
  return num_action_space_;
}
inline void InitRes::set_num_action_space(::google::protobuf::int32 value) {
  
  num_action_space_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.InitRes.num_action_space)
}

// .Message.MarineScv.TypeInfo my_marine_type = 2;
inline bool InitRes::has_my_marine_type() const {
  return this != internal_default_instance() && my_marine_type_ != NULL;
}
inline void InitRes::clear_my_marine_type() {
  if (GetArenaNoVirtual() == NULL && my_marine_type_ != NULL) {
    delete my_marine_type_;
  }
  my_marine_type_ = NULL;
}
inline const ::Message::MarineScv::TypeInfo& InitRes::_internal_my_marine_type() const {
  return *my_marine_type_;
}
inline const ::Message::MarineScv::TypeInfo& InitRes::my_marine_type() const {
  const ::Message::MarineScv::TypeInfo* p = my_marine_type_;
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitRes.my_marine_type)
  return p != NULL ? *p : *reinterpret_cast<const ::Message::MarineScv::TypeInfo*>(
      &::Message::MarineScv::_TypeInfo_default_instance_);
}
inline ::Message::MarineScv::TypeInfo* InitRes::release_my_marine_type() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.InitRes.my_marine_type)
  
  ::Message::MarineScv::TypeInfo* temp = my_marine_type_;
  my_marine_type_ = NULL;
  return temp;
}
inline ::Message::MarineScv::TypeInfo* InitRes::mutable_my_marine_type() {
  
  if (my_marine_type_ == NULL) {
    auto* p = CreateMaybeMessage<::Message::MarineScv::TypeInfo>(GetArenaNoVirtual());
    my_marine_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.InitRes.my_marine_type)
  return my_marine_type_;
}
inline void InitRes::set_allocated_my_marine_type(::Message::MarineScv::TypeInfo* my_marine_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete my_marine_type_;
  }
  if (my_marine_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      my_marine_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, my_marine_type, submessage_arena);
    }
    
  } else {
    
  }
  my_marine_type_ = my_marine_type;
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.InitRes.my_marine_type)
}

// .Message.MarineScv.TypeInfo my_scv_type = 3;
inline bool InitRes::has_my_scv_type() const {
  return this != internal_default_instance() && my_scv_type_ != NULL;
}
inline void InitRes::clear_my_scv_type() {
  if (GetArenaNoVirtual() == NULL && my_scv_type_ != NULL) {
    delete my_scv_type_;
  }
  my_scv_type_ = NULL;
}
inline const ::Message::MarineScv::TypeInfo& InitRes::_internal_my_scv_type() const {
  return *my_scv_type_;
}
inline const ::Message::MarineScv::TypeInfo& InitRes::my_scv_type() const {
  const ::Message::MarineScv::TypeInfo* p = my_scv_type_;
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitRes.my_scv_type)
  return p != NULL ? *p : *reinterpret_cast<const ::Message::MarineScv::TypeInfo*>(
      &::Message::MarineScv::_TypeInfo_default_instance_);
}
inline ::Message::MarineScv::TypeInfo* InitRes::release_my_scv_type() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.InitRes.my_scv_type)
  
  ::Message::MarineScv::TypeInfo* temp = my_scv_type_;
  my_scv_type_ = NULL;
  return temp;
}
inline ::Message::MarineScv::TypeInfo* InitRes::mutable_my_scv_type() {
  
  if (my_scv_type_ == NULL) {
    auto* p = CreateMaybeMessage<::Message::MarineScv::TypeInfo>(GetArenaNoVirtual());
    my_scv_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.InitRes.my_scv_type)
  return my_scv_type_;
}
inline void InitRes::set_allocated_my_scv_type(::Message::MarineScv::TypeInfo* my_scv_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete my_scv_type_;
  }
  if (my_scv_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      my_scv_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, my_scv_type, submessage_arena);
    }
    
  } else {
    
  }
  my_scv_type_ = my_scv_type;
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.InitRes.my_scv_type)
}

// .Message.MarineScv.TypeInfo en_unit_type = 4;
inline bool InitRes::has_en_unit_type() const {
  return this != internal_default_instance() && en_unit_type_ != NULL;
}
inline void InitRes::clear_en_unit_type() {
  if (GetArenaNoVirtual() == NULL && en_unit_type_ != NULL) {
    delete en_unit_type_;
  }
  en_unit_type_ = NULL;
}
inline const ::Message::MarineScv::TypeInfo& InitRes::_internal_en_unit_type() const {
  return *en_unit_type_;
}
inline const ::Message::MarineScv::TypeInfo& InitRes::en_unit_type() const {
  const ::Message::MarineScv::TypeInfo* p = en_unit_type_;
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitRes.en_unit_type)
  return p != NULL ? *p : *reinterpret_cast<const ::Message::MarineScv::TypeInfo*>(
      &::Message::MarineScv::_TypeInfo_default_instance_);
}
inline ::Message::MarineScv::TypeInfo* InitRes::release_en_unit_type() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.InitRes.en_unit_type)
  
  ::Message::MarineScv::TypeInfo* temp = en_unit_type_;
  en_unit_type_ = NULL;
  return temp;
}
inline ::Message::MarineScv::TypeInfo* InitRes::mutable_en_unit_type() {
  
  if (en_unit_type_ == NULL) {
    auto* p = CreateMaybeMessage<::Message::MarineScv::TypeInfo>(GetArenaNoVirtual());
    en_unit_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.InitRes.en_unit_type)
  return en_unit_type_;
}
inline void InitRes::set_allocated_en_unit_type(::Message::MarineScv::TypeInfo* en_unit_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete en_unit_type_;
  }
  if (en_unit_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      en_unit_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, en_unit_type, submessage_arena);
    }
    
  } else {
    
  }
  en_unit_type_ = en_unit_type;
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.InitRes.en_unit_type)
}

// repeated bool iswalkable = 5;
inline int InitRes::iswalkable_size() const {
  return iswalkable_.size();
}
inline void InitRes::clear_iswalkable() {
  iswalkable_.Clear();
}
inline bool InitRes::iswalkable(int index) const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.InitRes.iswalkable)
  return iswalkable_.Get(index);
}
inline void InitRes::set_iswalkable(int index, bool value) {
  iswalkable_.Set(index, value);
  // @@protoc_insertion_point(field_set:Message.MarineScv.InitRes.iswalkable)
}
inline void InitRes::add_iswalkable(bool value) {
  iswalkable_.Add(value);
  // @@protoc_insertion_point(field_add:Message.MarineScv.InitRes.iswalkable)
}
inline const ::google::protobuf::RepeatedField< bool >&
InitRes::iswalkable() const {
  // @@protoc_insertion_point(field_list:Message.MarineScv.InitRes.iswalkable)
  return iswalkable_;
}
inline ::google::protobuf::RepeatedField< bool >*
InitRes::mutable_iswalkable() {
  // @@protoc_insertion_point(field_mutable_list:Message.MarineScv.InitRes.iswalkable)
  return &iswalkable_;
}

// -------------------------------------------------------------------

// StepReq

// repeated .Message.MarineScv.Action action = 1;
inline int StepReq::action_size() const {
  return action_.size();
}
inline void StepReq::clear_action() {
  action_.Clear();
}
inline ::Message::MarineScv::Action* StepReq::mutable_action(int index) {
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.StepReq.action)
  return action_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::Action >*
StepReq::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:Message.MarineScv.StepReq.action)
  return &action_;
}
inline const ::Message::MarineScv::Action& StepReq::action(int index) const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.StepReq.action)
  return action_.Get(index);
}
inline ::Message::MarineScv::Action* StepReq::add_action() {
  // @@protoc_insertion_point(field_add:Message.MarineScv.StepReq.action)
  return action_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::Action >&
StepReq::action() const {
  // @@protoc_insertion_point(field_list:Message.MarineScv.StepReq.action)
  return action_;
}

// -------------------------------------------------------------------

// State

// repeated .Message.MarineScv.UInfo my_marine = 1;
inline int State::my_marine_size() const {
  return my_marine_.size();
}
inline void State::clear_my_marine() {
  my_marine_.Clear();
}
inline ::Message::MarineScv::UInfo* State::mutable_my_marine(int index) {
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.State.my_marine)
  return my_marine_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >*
State::mutable_my_marine() {
  // @@protoc_insertion_point(field_mutable_list:Message.MarineScv.State.my_marine)
  return &my_marine_;
}
inline const ::Message::MarineScv::UInfo& State::my_marine(int index) const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.State.my_marine)
  return my_marine_.Get(index);
}
inline ::Message::MarineScv::UInfo* State::add_my_marine() {
  // @@protoc_insertion_point(field_add:Message.MarineScv.State.my_marine)
  return my_marine_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >&
State::my_marine() const {
  // @@protoc_insertion_point(field_list:Message.MarineScv.State.my_marine)
  return my_marine_;
}

// repeated .Message.MarineScv.UInfo my_scv = 2;
inline int State::my_scv_size() const {
  return my_scv_.size();
}
inline void State::clear_my_scv() {
  my_scv_.Clear();
}
inline ::Message::MarineScv::UInfo* State::mutable_my_scv(int index) {
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.State.my_scv)
  return my_scv_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >*
State::mutable_my_scv() {
  // @@protoc_insertion_point(field_mutable_list:Message.MarineScv.State.my_scv)
  return &my_scv_;
}
inline const ::Message::MarineScv::UInfo& State::my_scv(int index) const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.State.my_scv)
  return my_scv_.Get(index);
}
inline ::Message::MarineScv::UInfo* State::add_my_scv() {
  // @@protoc_insertion_point(field_add:Message.MarineScv.State.my_scv)
  return my_scv_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >&
State::my_scv() const {
  // @@protoc_insertion_point(field_list:Message.MarineScv.State.my_scv)
  return my_scv_;
}

// repeated .Message.MarineScv.UInfo en_unit = 3;
inline int State::en_unit_size() const {
  return en_unit_.size();
}
inline void State::clear_en_unit() {
  en_unit_.Clear();
}
inline ::Message::MarineScv::UInfo* State::mutable_en_unit(int index) {
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.State.en_unit)
  return en_unit_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >*
State::mutable_en_unit() {
  // @@protoc_insertion_point(field_mutable_list:Message.MarineScv.State.en_unit)
  return &en_unit_;
}
inline const ::Message::MarineScv::UInfo& State::en_unit(int index) const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.State.en_unit)
  return en_unit_.Get(index);
}
inline ::Message::MarineScv::UInfo* State::add_en_unit() {
  // @@protoc_insertion_point(field_add:Message.MarineScv.State.en_unit)
  return en_unit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Message::MarineScv::UInfo >&
State::en_unit() const {
  // @@protoc_insertion_point(field_list:Message.MarineScv.State.en_unit)
  return en_unit_;
}

// -------------------------------------------------------------------

// StepRes

// int32 done = 1;
inline void StepRes::clear_done() {
  done_ = 0;
}
inline ::google::protobuf::int32 StepRes::done() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.StepRes.done)
  return done_;
}
inline void StepRes::set_done(::google::protobuf::int32 value) {
  
  done_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.StepRes.done)
}

// float reward = 2;
inline void StepRes::clear_reward() {
  reward_ = 0;
}
inline float StepRes::reward() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.StepRes.reward)
  return reward_;
}
inline void StepRes::set_reward(float value) {
  
  reward_ = value;
  // @@protoc_insertion_point(field_set:Message.MarineScv.StepRes.reward)
}

// .Message.MarineScv.State next_state = 3;
inline bool StepRes::has_next_state() const {
  return this != internal_default_instance() && next_state_ != NULL;
}
inline void StepRes::clear_next_state() {
  if (GetArenaNoVirtual() == NULL && next_state_ != NULL) {
    delete next_state_;
  }
  next_state_ = NULL;
}
inline const ::Message::MarineScv::State& StepRes::_internal_next_state() const {
  return *next_state_;
}
inline const ::Message::MarineScv::State& StepRes::next_state() const {
  const ::Message::MarineScv::State* p = next_state_;
  // @@protoc_insertion_point(field_get:Message.MarineScv.StepRes.next_state)
  return p != NULL ? *p : *reinterpret_cast<const ::Message::MarineScv::State*>(
      &::Message::MarineScv::_State_default_instance_);
}
inline ::Message::MarineScv::State* StepRes::release_next_state() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.StepRes.next_state)
  
  ::Message::MarineScv::State* temp = next_state_;
  next_state_ = NULL;
  return temp;
}
inline ::Message::MarineScv::State* StepRes::mutable_next_state() {
  
  if (next_state_ == NULL) {
    auto* p = CreateMaybeMessage<::Message::MarineScv::State>(GetArenaNoVirtual());
    next_state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.StepRes.next_state)
  return next_state_;
}
inline void StepRes::set_allocated_next_state(::Message::MarineScv::State* next_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete next_state_;
  }
  if (next_state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      next_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, next_state, submessage_arena);
    }
    
  } else {
    
  }
  next_state_ = next_state;
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.StepRes.next_state)
}

// -------------------------------------------------------------------

// ResetReq

// string content = 1;
inline void ResetReq::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResetReq::content() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.ResetReq.content)
  return content_.GetNoArena();
}
inline void ResetReq::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Message.MarineScv.ResetReq.content)
}
#if LANG_CXX11
inline void ResetReq::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Message.MarineScv.ResetReq.content)
}
#endif
inline void ResetReq::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Message.MarineScv.ResetReq.content)
}
inline void ResetReq::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Message.MarineScv.ResetReq.content)
}
inline ::std::string* ResetReq::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.ResetReq.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResetReq::release_content() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.ResetReq.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResetReq::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.ResetReq.content)
}

// -------------------------------------------------------------------

// ResetRes

// .Message.MarineScv.State next_state = 1;
inline bool ResetRes::has_next_state() const {
  return this != internal_default_instance() && next_state_ != NULL;
}
inline void ResetRes::clear_next_state() {
  if (GetArenaNoVirtual() == NULL && next_state_ != NULL) {
    delete next_state_;
  }
  next_state_ = NULL;
}
inline const ::Message::MarineScv::State& ResetRes::_internal_next_state() const {
  return *next_state_;
}
inline const ::Message::MarineScv::State& ResetRes::next_state() const {
  const ::Message::MarineScv::State* p = next_state_;
  // @@protoc_insertion_point(field_get:Message.MarineScv.ResetRes.next_state)
  return p != NULL ? *p : *reinterpret_cast<const ::Message::MarineScv::State*>(
      &::Message::MarineScv::_State_default_instance_);
}
inline ::Message::MarineScv::State* ResetRes::release_next_state() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.ResetRes.next_state)
  
  ::Message::MarineScv::State* temp = next_state_;
  next_state_ = NULL;
  return temp;
}
inline ::Message::MarineScv::State* ResetRes::mutable_next_state() {
  
  if (next_state_ == NULL) {
    auto* p = CreateMaybeMessage<::Message::MarineScv::State>(GetArenaNoVirtual());
    next_state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.ResetRes.next_state)
  return next_state_;
}
inline void ResetRes::set_allocated_next_state(::Message::MarineScv::State* next_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete next_state_;
  }
  if (next_state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      next_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, next_state, submessage_arena);
    }
    
  } else {
    
  }
  next_state_ = next_state;
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.ResetRes.next_state)
}

// -------------------------------------------------------------------

// Create

// string content = 1;
inline void Create::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Create::content() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.Create.content)
  return content_.GetNoArena();
}
inline void Create::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Message.MarineScv.Create.content)
}
#if LANG_CXX11
inline void Create::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Message.MarineScv.Create.content)
}
#endif
inline void Create::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Message.MarineScv.Create.content)
}
inline void Create::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Message.MarineScv.Create.content)
}
inline ::std::string* Create::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.Create.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Create::release_content() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.Create.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Create::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.Create.content)
}

// -------------------------------------------------------------------

// Close

// string content = 1;
inline void Close::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Close::content() const {
  // @@protoc_insertion_point(field_get:Message.MarineScv.Close.content)
  return content_.GetNoArena();
}
inline void Close::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Message.MarineScv.Close.content)
}
#if LANG_CXX11
inline void Close::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Message.MarineScv.Close.content)
}
#endif
inline void Close::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Message.MarineScv.Close.content)
}
inline void Close::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Message.MarineScv.Close.content)
}
inline ::std::string* Close::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:Message.MarineScv.Close.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Close::release_content() {
  // @@protoc_insertion_point(field_release:Message.MarineScv.Close.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Close::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:Message.MarineScv.Close.content)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MarineScv
}  // namespace Message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_marineScv_2eproto
